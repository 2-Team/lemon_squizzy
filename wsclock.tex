\newpage

\section{WS Clock} 

\subsection{Теория по алгоритму.}
Прежде чем перейти к алгоритму WS Clock, нужно обговорить и определить некоторые моменты и определения, встречающиеся в описании данного алгоритма.\\
Начнём с краткого описания определений, входящих в понятия "рабочий набор". \\
Замещение страниц по запросу - это когда страницы загружаются только по требованию, а не заранее, то есть наш процесс прерывается и ждет полной загрузки страницы. \\ 
Буксование - это когда каждую последующую нужную нам страницу приходится процессу загружать в память.\\
Для того чтобы не происходило частых прерываний, желательно чтобы часто использовавшиеся страницы загружались заранее, а остальные подгружались уже по необходимости.\\
Рабочий набор - это множество страниц (к), которое процесс использовал до некоторого момента времени (t).

\begin{figure}[h]
\center{\includegraphics[width=1\linewidth]{gr.gif}}
\caption{Зависимость рабочего набора w(k,t) от количества запрошенных страниц.}
\end{figure}

Другими словами рабочий набор переходит в насыщение, значение w(k,t) в состояние насыщения может служить для рабочего набора, который необходимо загружать именно до запуска процесса, не иначе\\
Теперь переходим к нашему алгоритму. WS Clock является модификацией алгоритма "рабочий набор". Для его использования необходима структура данных, которая представляет собой кольцевой список. В начальном положении этот список пуст. Когда же мы загружаем первую страницу, она добавляется в список и занимает положение "во главе". По мере "прихода" страниц они поступают в список, формируя замкнутое кольцо. Каждая запись, кроме бита R и бита M, содержит поле под названием «время последнего использования» из базового и уже выше упомянутого  алгоритма «рабочий набор».\\
Так же, как и в случае алгоритма «часы», при каждом, буквально каждом страничном прерывании первой будет проверятся та страница, на которую указывает стрелка наших "часов". Если бит R=1, то это значит, что страница использовалась в течение последнего такта времени, из-за она не является нашим претендентом на удаление. Тогда бит R устанавливается на 0, а стрелка двигается к следующей странице и для нее повторяется наш алгоритм.\\ 
Если же в момент проверки бит R=0 и время последнего использования больше "возраста страницы" T, то начинаем проверять бит M – были ли внесены изменения в нём. Если нет, то страница является нашей целью на удаление. Если изменения были – страница помечается как необходимый кандидат для копирования, а стрелка "часов" сдвигается.\\ 

\begin{figure}[h]
\center{\includegraphics[width=1\linewidth]{al.PNG}}
\caption{Работа алгоритма WSClock.}
\end{figure}

Если стрелка обходит полный круг и возвращается обратно, то возможно всего два варианта: \\
1) существует запланированная операция переноса страницы на диск; \\
2) вообще ничего не запланировано. \\
В первом варианте будет выбрана первая попавшаяся страница без изменений с битом R=0. Во втором случае нам предъявляются права на совершенно любую страницу. \\
Одним из наилучших алгоритмов является как раз алгоритм WSCIock. Он обеспечивает хорошую постраничную подкачку.\\ 
Но как и у любого алгоритма у него есть тоже недостатки – размеры страниц и частота страничных прерываний достаточно сильно влияют на производительность нашего алгоритма, все данные находятся в состояние "хаоса", то есть они перемешаны друг с другом. 

\subsection{Код алгоритма.}







